/*
Copyright (c) 2022 Wojciech Nawrocki. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Wojciech Nawrocki
*/

const {
    -- Minimum size of a row/column in the object grid.
    gridMinSize = 150
    gridPadHorizontal = 50
    gridPadVertical = 50
    curveOffset = 20
    labelOffsetFrac = 0.3
}

forall Targettable x {
    -- The `center` is the "root" position of a targettable. Cells targetting
    -- this targettable start/end at positions relative to the center.
    -- HACK: The optimization variable has to be defined in terms of two separate
    -- floats to force Penrose to track dependencies at this granularity rather
    -- than treating the whole vector as one, unbreakable entity. Otherwise, it
    -- thinks the assignment
    --   u ← (u[0], v[1]); v ← (u[0], v[1])
    -- is circular.
    float x.centerX = ?
    float x.centerY = ?
    vec2 x.center = (x.centerX, x.centerY)
    -- The `textBoxCenter` is where the text box is. It may differ from `center`
    -- when the label is offset towards one side.
    vec2 x.textBoxCenter = x.center

    shape x.textBox = Rectangle {
        center : x.textBoxCenter
        cornerRadius : 5
        -- Default size, will be overwritten dynamically.
        width : 50
        height : 30
    }

    -- NOTE: Not used anymore, we use the opt engine instead.
    -- Sides of a Targettable where the ends of cells targetting it are attached.
    -- +-T-+
    -- L C R
    -- +-B-+
    -- vec2 x.left = x.center - (x.textBox.width / 2, 0)
    -- vec2 x.right = x.center + (x.textBox.width / 2, 0)
    -- vec2 x.top = x.center + (0, x.textBox.height / 2)
    -- vec2 x.bottom = x.center - (0, x.textBox.height / 2)

    -- NOTE: Useful for debugging but we don't want it in the actual output.
    -- shape x.text = Equation {
    --     center : x.textBox.center
    --     string : x.label
    --     fontSize : "11pt"
    -- }
    -- x.textLayering = x.text above x.textBox
}

forall Object A {
    -- Draw diagram towards top-left.
    encourage minimal(A.centerX)
    encourage maximal(A.centerY)

    -- We optimize the sizes of every row and column in a grid which determines
    -- object placement. Each object keeps track of the size of the grid column
    -- to the right of it, and the grid row below it. Positioning predicates propagate
    -- these, for example IsLeftHorizontal/IsRightHorizontal propagates gridBelow.
    -- Sizes propagate to the right and downwards so that the leftmost, uppermost
    -- object is the "root" of the diagram.
    --
    -- Penrose objectives are arbitrary reals, so to obtain a positive value we make
    -- the it the square of an objective. The size of a grid row/column is then the minimal,
    -- fixed size `gridMinSize` plus an optimized offset.
    float preGridRight = ?
    float preGridBelow = ?
    float gridRight = preGridRight*preGridRight
    float gridBelow = preGridBelow*preGridBelow
    float A.gridRight = const.gridMinSize + gridRight
    float A.gridBelow = const.gridMinSize + gridBelow

    encourage minimal(gridRight)
    encourage minimal(gridBelow)
}

forall Cell f; Targettable A; Targettable B
where f := MakeCell(A, B) {
    -- Cells are drawn as arrows between the centres of their endpoints,
    -- but shortened on both ends to make room for the text boxes.
    float preOffStart = ?
    float preOffEnd = ?
    float offStart = preOffStart*preOffStart
    float offEnd = preOffEnd*preOffEnd
    vec2 f.dir = normalize(B.center - A.center)
    vec2 f.start = A.center + f.dir * offStart
    vec2 f.end = B.center - f.dir * offEnd
    vec2 f.mid = (f.start + f.end) / 2

    -- Make arrows as long as possible (offsets as short as possible) subject
    -- to them being outside the labels.
    --
    -- HACK: These circles are not drawn. They only exist to ensure the arrow
    -- endpoints are outside the text boxes, and afaict there is no `distanceToShape`.
    -- Circles are the simplest shape, so I am guessing this is cheaper than
    -- `disjoint(arrowShape, A.textBox)`.
    shape cStart = Circle {
        center: f.start
        r: 2
        fillColor: rgba(0,0,0,0)
    }
    shape cStartBig = Circle {
        center: f.start
        r: 4
        fillColor: rgba(0,0,0,0)
    }
    shape cEnd = Circle {
        center: f.end
        r: 2
        fillColor: rgba(0,0,0,0)
    }
    shape cEndBig = Circle {
        center: f.end
        r: 4
        fillColor: rgba(0,0,0,0)
    }
    ensure disjoint(cStart, A.textBox)
    ensure disjoint(cEnd, B.textBox)
    ensure overlapping(cStartBig, A.textBox)
    ensure overlapping(cEndBig, B.textBox)
    -- TODO: This ends up with double-digit values way too often. Thus the `ensure`s above.
    -- encourage minimal(offStart)
    -- encourage minimal(offEnd)

    -- The center of a cell is not optimized but rather defined as its midpoint.
    override f.centerX = f.mid[0]
    override f.centerY = f.mid[1]

    -- How much space this cell needs horizontally and vertically
    float f.spaceH = A.textBox.width / 2 + f.textBox.width + B.textBox.width / 2 + const.gridPadHorizontal
    float f.spaceV = A.textBox.height / 2 + f.textBox.height + B.textBox.height / 2 + const.gridPadVertical

    shape f.shape = Line {
        start: f.start
        end: f.end
        endArrowhead: "line"
        strokeColor: rgba(0,0,0,100)
    }

    f.cellTextLayering = f.textBox above f.shape
    f.cellTextLayeringA = A.textBox above f.shape
    f.cellTextLayeringB = B.textBox above f.shape
}

forall Cell a; Cell f; Cell g
where a := MakeCell(f, g) {
    -- TODO: need a custom svg function to create nice double arrow for 2-cells
}

forall Cell f; Object A; Object B
where f := MakeCell(A, B); IsLeftHorizontal(f) {
    ensure equal(A.centerX, B.centerX + B.gridRight)
    ensure equal(A.centerY, B.centerY)
    ensure equal(A.gridBelow, B.gridBelow)

    encourage lessThan(f.spaceH, B.gridRight)
}

forall Cell f; Object A; Object B
where f := MakeCell(A, B); IsRightHorizontal(f) {
    ensure equal(B.centerX, A.centerX + A.gridRight)
    ensure equal(B.centerY, A.centerY)
    ensure equal(B.gridBelow, A.gridBelow)

    encourage lessThan(f.spaceH, A.gridRight)
}

forall Cell f; Object A; Object B
where f := MakeCell(A, B); IsUpVertical(f) {
    ensure equal(A.centerX, B.centerX)
    ensure equal(A.centerY, B.centerY - B.gridBelow)
    ensure equal(A.gridRight, B.gridRight)

    encourage lessThan(f.spaceV, B.gridBelow)
}

forall Cell f; Object A; Object B
where f := MakeCell(A, B); IsDownVertical(f) {
    ensure equal(B.centerX, A.centerX)
    ensure equal(B.centerY, A.centerY - A.gridBelow)
    ensure equal(B.gridRight, A.gridRight)

    encourage lessThan(f.spaceV, A.gridBelow)
}

forall Cell f; Object A; Object B
where f := MakeCell(A, B); IsLeftUpDiagonal(f) {
    ensure equal(A.centerX, B.centerX + B.gridRight)
    ensure equal(A.centerY, B.centerY - B.gridBelow)

    encourage lessThan(f.spaceH, B.gridRight)
    encourage lessThan(f.spaceV, B.gridBelow)
}

forall Cell f; Object A; Object B
where f := MakeCell(A, B); IsLeftDownDiagonal(f) {
    -- Convention: grid constraints propagate to the right and downwards
    -- so the equalities here are flipped.
    ensure equal(A.centerX, B.centerX + B.gridRight)
    ensure equal(B.centerY, A.centerY - A.gridBelow)

    encourage lessThan(f.spaceH, B.gridRight)
    encourage lessThan(f.spaceV, A.gridBelow)
}

forall Cell f; Object A; Object B
where f := MakeCell(A, B); IsRightUpDiagonal(f) {
    ensure equal(B.centerX, A.centerX + A.gridRight)
    ensure equal(A.centerY, B.centerY - B.gridBelow)

    encourage lessThan(f.spaceH, A.gridRight)
    encourage lessThan(f.spaceV, B.gridBelow)
}

forall Cell f; Object A; Object B
where f := MakeCell(A, B); IsRightDownDiagonal(f) {
    ensure equal(B.centerX, A.centerX + A.gridRight)
    ensure equal(B.centerY, A.centerY - A.gridBelow)

    encourage lessThan(f.spaceH, A.gridRight)
    encourage lessThan(f.spaceV, A.gridBelow)
}

forall Cell f; Targettable A; Targettable B
where f := MakeCell(A, B); IsCurvedLeft(f) {
    vec2 dirLeft = rot90(f.dir)
    vec2 newCenter = f.mid + dirLeft * const.curveOffset
    override f.centerX = newCenter[0]
    override f.centerY = newCenter[1]
    override f.shape = Path {
        d: interpolateQuadraticFromPoints("open", f.start, f.center, f.end)
        endArrowhead: "line"
        strokeColor: rgba(0,0,0,100)
    }
}

forall Cell f; Targettable A; Targettable B
where f := MakeCell(A, B); IsCurvedRight(f) {
    vec2 dirRight = rot90(rot90(rot90(f.dir))) -- lol
    vec2 newCenter = f.mid + dirRight * const.curveOffset
    override f.centerX = newCenter[0]
    override f.centerY = newCenter[1]
    override f.shape = Path {
        d: interpolateQuadraticFromPoints("open", f.start, f.center, f.end)
        endArrowhead: "line"
        strokeColor: rgba(0,0,0,100)
    }
}

forall Cell f; Targettable A; Targettable B
where f := MakeCell(A, B); IsLabelLeft(f) {
    vec2 dirLeft = rot90(f.dir)
    -- Distance from arrow midpoint to `dirLeft` point on box if the box were an ellipse
    float dist = norm((dirLeft[0] * f.textBox.width, dirLeft[1] * f.textBox.height))
    override f.textBoxCenter = f.center + dirLeft * dist * const.labelOffsetFrac
}

forall Cell f; Targettable A; Targettable B
where f := MakeCell(A, B); IsLabelRight(f) {
    vec2 dirRight = rot90(rot90(rot90(f.dir)))
    -- Distance from arrow midpoint to `dirRight` point on box if the box were an ellipse
    float dist = norm((dirRight[0] * f.textBox.width, dirRight[1] * f.textBox.height))
    override f.textBoxCenter = f.center + dirRight * dist * const.labelOffsetFrac
}

forall Cell f; Targettable A; Targettable B
where f := MakeCell(A, B); IsDashed(f) {
    override f.shape.strokeStyle = "dashed"
}

forall Cell f; Targettable A; Targettable B
where f := MakeCell(A, B); IsMono(f) {
    override f.shape.startArrowhead = "line"
    override f.shape.flipStartArrowhead = true
}

forall Cell f; Targettable A; Targettable B
where f := MakeCell(A, B); IsEpi(f) {
    override f.shape.endArrowhead = "doubleLine"
}

forall Cell f; Targettable A; Targettable B
where f := MakeCell(A, B); IsEmbedding(f) {
    override f.shape.startArrowhead = "loopup"
}
